#include "nios2_ctrl_reg_macros.h"
#include "address_map_nios2.h"
#include <stdio.h>

/* these globals are written by interrupt service routines; we have to declare
 * these as volatile to avoid the compiler caching their values in registers */
extern volatile char byte1, byte2, byte3;			// modified by PS/2 interrupt service routine
extern volatile int record, play, buffer_index;		// used for audio
extern volatile int timeout;						// used to synchronize with the timer

/* function prototypes */
void LCD_cursor( int, int );
void LCD_text( char * );
void LCD_cursor_off( void );
void VGA_text (int, int, char *);
void VGA_box (int, int, int, int, short);
void HEX_PS2(char, char, char);

/*******************************************************************************
 * This program demonstrates use of the media ports in the computer system
 *
 * It performs the following:
 *  1. records audio for about 10 seconds when an interrupt is generated by
 *     pressing KEY[0]. LEDG[0] is lit while recording. Audio recording is
 *     controlled by using interrupts
 * 	2. plays the recorded audio when an interrupt is generated by pressing
 *     KEY[1]. LEDG[1] is lit while playing. Audio playback is controlled by
 *     using interrupts
 * 	3. draws a blue box on the VGA display, and places a text string inside
 *     the box. Also, moves the word INTEL around the display, "bouncing"
 *     off the blue box and screen edges
 * 	4. displays the last three bytes of data received from the PS/2 port
 *     on the HEX displays. The PS/2 port is handled using interrupts
 * 	5. the speed of scrolling the LCD display and of refreshing the VGA screen
 *     are controlled by interrupts from the interval timer
 * 	6. shows a text message on the LCD display, and scrolls the message
 ******************************************************************************/
int main(void)
{

	/* Declare volatile pointers to I/O registers (volatile means that IO load
	   and store instructions will be used to access these pointer locations,
	   instead of regular memory loads and stores) */
	volatile int * interval_timer_ptr = (int *) TIMER_BASE;		// interal timer base address
	volatile int * KEY_ptr = (int *) KEY_BASE;					// pushbutton KEY address
	volatile int * audio_ptr = (int *) AUDIO_BASE;				// audio port address
	volatile int * PS2_ptr = (int *) PS2_BASE;					// PS/2 port address
  	volatile char * LCD_display_ptr = (char *) CHAR_LCD_BASE;	// 16x2 character display
		volatile int * GPIO_ptr = (int *) JP5_BASE;

	/* initialize some variables */
	byte1 = 0; byte2 = 0; byte3 = 0; 			// used to hold PS/2 data
	record = 0; play = 0; buffer_index = 0;		// used for audio record/playback
	timeout = 0;								// synchronize with the timer

	/* these variables are used for a blue box and a "bouncing" ALTERA on the VGA screen */
	int INTEL_x1; int INTEL_x2; int INTEL_y;
	int INTEL_inc_x; int INTEL_inc_y;
	int blue_x1; int blue_y1; int blue_x2; int blue_y2;
	int screen_x; int screen_y; int char_buffer_x; int char_buffer_y;
	short color;

	/* set the interval timer period for scrolling the HEX displays */
	int counter = 10000000;				// 1/(50 MHz) x (10000000) = 200 msec
	*(interval_timer_ptr + 0x2) = (counter & 0xFFFF);
	*(interval_timer_ptr + 0x3) = (counter >> 16) & 0xFFFF;

	/* start interval timer, enable its interrupts */
	*(interval_timer_ptr + 1) = 0x7;	// STOP = 0, START = 1, CONT = 1, ITO = 1

	*(KEY_ptr + 2) = 0xF;				/* write to the pushbutton interrupt mask register, and
										 * enable interrupts on all four KEYs */

	*(PS2_ptr) = 0xFF;					/* reset */
	*(PS2_ptr + 1) = 0x1;				/* write to the PS/2 Control register to enable interrupts */

	NIOS2_WRITE_IENABLE( 0xC3 );		/* set interrupt mask bits for levels 0 (interval
										 * timer), 1 (pushbuttons), 6 (audio), and 7 (PS/2) */

	NIOS2_WRITE_STATUS( 1 );			// enable Nios II interrupts

	/* create a messages to be displayed on the VGA and LCD displays */
	char text_top_LCD[80] = "Welcome to the Intel FPGA\0";
	char text_top_VGA[20] = "Intel FPGA\0";
	char text_bottom[20] = "Computer Systems\0";
	char text_INTEL[10] = "INTEL\0";
	char text_erase[10] = "     \0";

	/* output text message to the LCD */
	*(LCD_display_ptr) = 0x02;			// return text to home position
	LCD_cursor (0,0);					// set LCD cursor location to top row
	LCD_text (text_top_LCD);
	LCD_cursor (0,1);					// set LCD cursor location to bottom row
	LCD_text (text_bottom);
	LCD_cursor_off ();					// turn off the LCD cursor

	/* the following variables give the size of the pixel buffer */
	screen_x = 319; screen_y = 239;
	color = 0;
	VGA_box (0, 0, screen_x, screen_y, color);	// erase everything on the screen
	// draw a medium-blue box around the above text, based on the character buffer coordinates
	blue_x1 = 31; blue_x2 = 49; blue_y1 = 28; blue_y2 = 32;
	// character coords * 4 since characters are 4 x 4 pixel buffer coords (8 x 8 VGA coords)
	color = 0x187F;		// a medium blue color
	VGA_box (blue_x1 * 4, blue_y1 * 4, blue_x2 * 4 - 1, blue_y2 * 4 - 1, color);
	/* output text message in the middle of the VGA monitor */
	/* First clear the character buffer */
	int *p;
	for (p = (int*)FPGA_CHAR_BASE; p < (int*)FPGA_CHAR_END; ++p)
		*p = 0;
	VGA_text (blue_x1 + 4, blue_y1 + 1, text_top_VGA);
	VGA_text (blue_x1 + 1, blue_y1 + 2, text_bottom);

	char_buffer_x = 79; char_buffer_y = 59;
	INTEL_x1 = 0; INTEL_x2 = 4/* INTEL = 5 chars */; INTEL_y = 0; INTEL_inc_x = 1; INTEL_inc_y = 1;
	VGA_text (INTEL_x1, INTEL_y, text_INTEL);
	while (1)
	{
		while (!timeout)
			;	// wait to synchronize with timer
			printf("%x\n", *GPIO_ptr);
		/* move the INTEL text around on the VGA screen */
		VGA_text (INTEL_x1, INTEL_y, text_erase);		// erase
		INTEL_x1 += INTEL_inc_x;
		INTEL_x2 += INTEL_inc_x;
		INTEL_y += INTEL_inc_y;

		if ( (INTEL_y == char_buffer_y) || (INTEL_y == 0) )
			INTEL_inc_y = -(INTEL_inc_y);
		if ( (INTEL_x2 == char_buffer_x) || (INTEL_x1 == 0) )
			INTEL_inc_x = -(INTEL_inc_x);

		if ( (INTEL_y >= blue_y1 - 1) && (INTEL_y <= blue_y2 + 1) )
		{
			if ( ((INTEL_x1 >= blue_x1 - 1) && (INTEL_x1 <= blue_x2 + 1)) ||
				((INTEL_x2 >= blue_x1 - 1) && (INTEL_x2 <= blue_x2 + 1)) )
			{
				if ( (INTEL_y == (blue_y1 - 1)) || (INTEL_y == (blue_y2 + 1)) )
					INTEL_inc_y = -(INTEL_inc_y);
				else
					INTEL_inc_x = -(INTEL_inc_x);
			}
		}
		VGA_text (INTEL_x1, INTEL_y, text_INTEL);

		/* display PS/2 data (from interrupt service routine) on HEX displays */
		HEX_PS2 (byte1, byte2, byte3);
		timeout = 0;
	}
}

/********************************************************************************
 * Subroutine to move the LCD cursor
********************************************************************************/
void LCD_cursor(int x, int y)
{
  	volatile char * LCD_display_ptr = (char *) CHAR_LCD_BASE;	// 16x2 character display
	char instruction;

	instruction = x;
	if (y != 0) instruction |= 0x40;			// set bit 6 for bottom row
	instruction |= 0x80;						// need to set bit 7 to set the cursor location
	*(LCD_display_ptr) = instruction;			// write to the LCD instruction register
}

/*******************************************************************************
 * Subroutine to send a string of text to the LCD
 ******************************************************************************/
void LCD_text(char * text_ptr)
{
  	volatile char * LCD_display_ptr = (char *) CHAR_LCD_BASE;	// 16x2 character display

	while ( *(text_ptr) )
	{
		*(LCD_display_ptr + 1) = *(text_ptr);	// write to the LCD data register
		++text_ptr;
	}
}

/*******************************************************************************
 * Subroutine to turn off the LCD cursor
 ******************************************************************************/
void LCD_cursor_off(void)
{
  	volatile char * LCD_display_ptr = (char *) CHAR_LCD_BASE;	// 16x2 character display
	*(LCD_display_ptr) = 0x0C;									// turn off the LCD cursor
}

/*******************************************************************************
 * Subroutine to send a string of text to the VGA monitor
 ******************************************************************************/
void VGA_text(int x, int y, char * text_ptr)
{
	int offset;
  	volatile char * character_buffer = (char *) FPGA_CHAR_BASE;	// VGA character buffer

	/* assume that the text string fits on one line */
	offset = (y << 7) + x;
	while ( *(text_ptr) )
	{
		*(character_buffer + offset) = *(text_ptr);	// write to the character buffer
		++text_ptr;
		++offset;
	}
}

/*******************************************************************************
 * Draw a filled rectangle on the VGA monitor
 ******************************************************************************/
void VGA_box(int x1, int y1, int x2, int y2, short pixel_color)
{
	int offset, row, col;
  	volatile short * pixel_buffer = (short *) FPGA_SRAM_BASE;	// VGA pixel buffer

	/* assume that the box coordinates are valid */
	for (row = y1; row <= y2; row++)
	{
		col = x1;
		while (col <= x2)
		{
			offset = (row << 9) + col;
			*(pixel_buffer + offset) = pixel_color;	// compute halfword address, set pixel
			++col;
		}
	}
}

/*******************************************************************************
 * Subroutine to show a string of HEX data on the HEX displays
 ******************************************************************************/
void HEX_PS2(char b1, char b2, char b3)
{
	volatile int * HEX3_HEX0_ptr = (int *) HEX3_HEX0_BASE;
	volatile int * HEX7_HEX4_ptr = (int *) HEX7_HEX4_BASE;

	/* SEVEN_SEGMENT_DECODE_TABLE gives the on/off settings for all segments in
	 * a single 7-seg display, for the hex digits 0 - F */
	unsigned char	seven_seg_decode_table[] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07,
		  										0x7F, 0x67, 0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71 };
	unsigned char	hex_segs[] = { 0, 0, 0, 0, 0, 0, 0, 0 };
	unsigned int shift_buffer, nibble;
	unsigned char code;
	int i;

	shift_buffer = (b1 << 16) | (b2 << 8) | b3;
	for ( i = 0; i < 6; ++i )
	{
		nibble = shift_buffer & 0x0000000F;		// character is in rightmost nibble
		code = seven_seg_decode_table[nibble];
		hex_segs[i] = code;
		shift_buffer = shift_buffer >> 4;
	}
	/* drive the hex displays */
	*(HEX3_HEX0_ptr) = *(int *) (hex_segs);
	*(HEX7_HEX4_ptr) = *(int *) (hex_segs+4);
}
